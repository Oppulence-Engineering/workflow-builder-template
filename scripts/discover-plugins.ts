#!/usr/bin/env tsx
/**
 * Plugin Auto-Discovery Script
 *
 * Automatically discovers all plugins in the plugins/ directory and generates
 * the plugins/index.ts file with imports. Also updates the README.md with
 * the current list of available actions.
 *
 * Run this script:
 * - Manually: pnpm discover-plugins
 * - Automatically: Before build (in package.json)
 */

import {
  existsSync,
  mkdirSync,
  readdirSync,
  readFileSync,
  statSync,
  writeFileSync,
} from "node:fs";
import { dirname, join } from "node:path";

const PLUGINS_DIR = join(process.cwd(), "plugins");
const EXTENSIONS_PLUGINS_DIR = join(process.cwd(), "extensions", "plugins");
const OUTPUT_FILE = join(PLUGINS_DIR, "index.ts");
const TYPES_FILE = join(process.cwd(), "lib", "types", "integration.ts");
const STEP_REGISTRY_FILE = join(process.cwd(), "lib", "step-registry.ts");
const README_FILE = join(process.cwd(), "README.md");
const PLUGINS_MARKER_REGEX =
  /<!-- PLUGINS:START[^>]*-->[\s\S]*?<!-- PLUGINS:END -->/;

// Regex to validate JavaScript identifiers
const VALID_IDENTIFIER_REGEX = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/;

/**
 * Check if a string is a valid JavaScript identifier
 */
function isValidIdentifier(str: string): boolean {
  return VALID_IDENTIFIER_REGEX.test(str);
}

/**
 * Legacy action type mappings for backward compatibility
 * Maps old label-based action types to new namespaced IDs
 */
const LEGACY_ACTION_MAPPINGS: Record<string, string> = {
  "Send Email": "resend:send-email",
  "Send Slack Message": "slack:send-message",
  "Create Linear Ticket": "linear:create-ticket",
  "Scrape Website": "firecrawl:scrape",
  "Search Web": "firecrawl:search",
  "Generate Text": "ai-gateway:generate-text",
  "Generate Image": "ai-gateway:generate-image",
  "Generate with v0": "v0:generate",
};

/**
 * Convert a string to kebab-case
 */
function toKebabCase(str: string): string {
  return str
    .replace(/([a-z])([A-Z])/g, "$1-$2")
    .replace(/\s+/g, "-")
    .toLowerCase();
}

/**
 * Compute a namespaced action ID from integration type and action slug/id
 * Uses slug if available, otherwise converts id to kebab-case
 */
function computeActionId(
  integrationType: string,
  actionSlug: string | undefined,
  actionId?: string
): string {
  const slug = actionSlug || (actionId ? toKebabCase(actionId) : "unknown");
  return `${integrationType}:${slug}`;
}

// System integrations that don't have plugins
const SYSTEM_INTEGRATION_TYPES = ["database"] as const;

/**
 * Discover plugin directories in a given path
 */
function discoverPluginsInDir(dir: string): string[] {
  if (!existsSync(dir)) {
    return [];
  }

  const entries = readdirSync(dir);

  const plugins = entries.filter((entry) => {
    // Skip special directories and files
    if (
      entry.startsWith("_") ||
      entry.startsWith(".") ||
      entry === "index.ts" ||
      entry === "registry.ts" ||
      entry === "types.ts"
    ) {
      return false;
    }

    // Only include directories
    const fullPath = join(dir, entry);
    try {
      return statSync(fullPath).isDirectory();
    } catch {
      return false;
    }
  });

  return plugins.sort();
}

/**
 * Discover all plugin directories (core + extensions)
 */
function discoverPlugins(): string[] {
  return discoverPluginsInDir(PLUGINS_DIR);
}

/**
 * Discover extension plugin directories
 */
function discoverExtensionPlugins(): string[] {
  return discoverPluginsInDir(EXTENSIONS_PLUGINS_DIR);
}

/**
 * Generate the plugins/index.ts file
 */
function generateIndexFile(
  plugins: string[],
  extensionPlugins: string[]
): void {
  const imports = plugins.map((plugin) => `import "./${plugin}";`).join("\n");
  const extensionImports = extensionPlugins
    .map((plugin) => `import "@/extensions/plugins/${plugin}";`)
    .join("\n");

  const allPlugins = [...plugins, ...extensionPlugins.map((p) => `ext:${p}`)];

  const content = `/**
 * Plugins Index (Auto-Generated)
 *
 * This file is automatically generated by scripts/discover-plugins.ts
 * DO NOT EDIT MANUALLY - your changes will be overwritten!
 *
 * To add a new integration:
 * 1. Create a new directory in plugins/ (e.g., plugins/my-integration/)
 * 2. Add your plugin files (index.tsx, steps/, codegen/, etc.)
 * 3. Run: pnpm discover-plugins (or it runs automatically on build)
 *
 * To remove an integration:
 * 1. Delete the plugin directory
 * 2. Run: pnpm discover-plugins (or it runs automatically on build)
 *
 * Discovered plugins: ${allPlugins.join(", ") || "none"}
 */

${imports || "// No plugins discovered"}

// Fork-specific extension plugins
${extensionImports || "// No extension plugins discovered"}

export type { IntegrationPlugin, PluginAction, ActionWithFullId } from "./registry";

// Export the registry utilities
export {
  computeActionId,
  findActionById,
  generateAIActionPrompts,
  getActionsByCategory,
  getAllActions,
  getAllDependencies,
  getAllEnvVars,
  getAllIntegrations,
  getCredentialMapping,
  getDependenciesForActions,
  getIntegration,
  getIntegrationLabels,
  getIntegrationTypes,
  getPluginEnvVars,
  getSortedIntegrationTypes,
  parseActionId,
  registerIntegration,
} from "./registry";
`;

  writeFileSync(OUTPUT_FILE, content, "utf-8");
}

/**
 * Update the README.md with the current list of actions
 */
async function updateReadme(): Promise<void> {
  // Dynamically import the plugins to populate the registry
  // This works because we already generated plugins/index.ts above
  await import("@/plugins/index");

  // Now import the registry utilities
  const { getAllIntegrations } = await import("@/plugins/registry");

  const integrations = getAllIntegrations();

  if (integrations.length === 0) {
    console.log("‚ö†Ô∏è  No integrations found, skipping README update");
    return;
  }

  // Generate markdown list grouped by integration
  const actionsList = integrations
    .map((integration) => {
      const actionLabels = integration.actions.map((a) => a.label).join(", ");
      return `- **${integration.label}**: ${actionLabels}`;
    })
    .join("\n");

  // Read current README
  const readme = readFileSync(README_FILE, "utf-8");

  // Check if markers exist
  if (!readme.includes("<!-- PLUGINS:START")) {
    console.log("‚ö†Ô∏è  README markers not found, skipping README update");
    return;
  }

  // Replace content between markers
  const updated = readme.replace(
    PLUGINS_MARKER_REGEX,
    `<!-- PLUGINS:START - Do not remove. Auto-generated by discover-plugins -->\n${actionsList}\n<!-- PLUGINS:END -->`
  );

  writeFileSync(README_FILE, updated, "utf-8");
  console.log(
    `üìù Updated README.md with ${integrations.length} integration(s)`
  );
}

/**
 * Generate the lib/types/integration.ts file with dynamic types
 */
async function generateTypesFile(): Promise<void> {
  // Ensure the types directory exists
  const typesDir = dirname(TYPES_FILE);
  if (!existsSync(typesDir)) {
    mkdirSync(typesDir, { recursive: true });
  }

  // Get plugin types from registry
  const { getIntegrationTypes } = await import("@/plugins/registry");
  const pluginTypes = getIntegrationTypes();

  // Combine plugin types with system types
  const allTypes = [...pluginTypes, ...SYSTEM_INTEGRATION_TYPES].sort();

  // Generate the union type
  const unionType = allTypes.map((t) => `  | "${t}"`).join("\n");

  const content = `/**
 * Integration Types (Auto-Generated)
 *
 * This file is automatically generated by scripts/discover-plugins.ts
 * DO NOT EDIT MANUALLY - your changes will be overwritten!
 *
 * To add a new integration type:
 * 1. Create a plugin in plugins/ directory, OR
 * 2. Add a system integration to SYSTEM_INTEGRATION_TYPES in discover-plugins.ts
 * 3. Run: pnpm discover-plugins
 *
 * Generated types: ${allTypes.join(", ")}
 */

// Integration type union - plugins + system integrations
export type IntegrationType =
${unionType};

// Generic config type - plugins define their own keys via formFields[].configKey
export type IntegrationConfig = Record<string, string | undefined>;
`;

  writeFileSync(TYPES_FILE, content, "utf-8");
  console.log(
    `üìù Generated lib/types/integration.ts with ${allTypes.length} type(s)`
  );
}

/**
 * Generate the lib/step-registry.ts file with step import functions
 * This enables dynamic imports that are statically analyzable by the bundler
 */
async function generateStepRegistry(
  extensionPluginsList: string[]
): Promise<void> {
  const { getAllIntegrations } = await import("@/plugins/registry");
  const integrations = getAllIntegrations();

  // Collect all action -> step mappings
  const stepEntries: Array<{
    actionId: string;
    label: string;
    integration: string;
    stepImportPath: string;
    stepFunction: string;
    isExtension: boolean;
  }> = [];

  for (const integration of integrations) {
    // Check if this is an extension plugin
    const isExtension = extensionPluginsList.includes(integration.type);

    for (const action of integration.actions) {
      // Use slug if available, otherwise use id (for extension plugins)
      const fullActionId = computeActionId(
        integration.type,
        action.slug,
        action.id
      );
      stepEntries.push({
        actionId: fullActionId,
        label: action.label,
        integration: integration.type,
        stepImportPath: action.stepImportPath,
        stepFunction: action.stepFunction,
        isExtension,
      });
    }
  }

  // Build reverse mapping from action IDs to legacy labels
  const legacyLabelsForAction: Record<string, string[]> = {};
  for (const [legacyLabel, actionId] of Object.entries(
    LEGACY_ACTION_MAPPINGS
  )) {
    if (!legacyLabelsForAction[actionId]) {
      legacyLabelsForAction[actionId] = [];
    }
    legacyLabelsForAction[actionId].push(legacyLabel);
  }

  // Generate label entries for action ID to label mapping
  const labelEntries = stepEntries
    .map(({ actionId, label }) => {
      const key = isValidIdentifier(actionId) ? actionId : `"${actionId}"`;
      return `  ${key}: "${label}",`;
    })
    .join("\n");

  // Generate legacy label entries for backward compatibility
  const legacyLabelEntries = Object.entries(LEGACY_ACTION_MAPPINGS)
    .map(([legacyLabel, actionId]) => {
      const entry = stepEntries.find((e) => e.actionId === actionId);
      const label = entry?.label || legacyLabel;
      return `  "${legacyLabel}": "${label}",`;
    })
    .join("\n");

  // Generate the step importer map with static imports
  // Include both namespaced IDs and legacy label-based IDs for backward compatibility
  // Note: Core plugins have steps directly in steps/ folder (e.g., steps/send-email.ts)
  // Extension plugins have steps in subdirectories (e.g., steps/s3-upload/step.ts)
  const importerEntries = stepEntries
    .map(
      ({
        actionId,
        integration,
        stepImportPath,
        stepFunction,
        isExtension,
      }) => {
        const key = isValidIdentifier(actionId) ? actionId : `"${actionId}"`;
        const importPath = isExtension
          ? `@/extensions/plugins/${integration}/steps/${stepImportPath}/step`
          : `@/plugins/${integration}/steps/${stepImportPath}`;
        return `  ${key}: {
    importer: () => import("${importPath}"),
    stepFunction: "${stepFunction}",
  },`;
      }
    )
    .join("\n");

  const content = `/**
 * Step Registry (Auto-Generated)
 *
 * This file is automatically generated by scripts/discover-plugins.ts
 * DO NOT EDIT MANUALLY - your changes will be overwritten!
 *
 * This registry enables dynamic step imports that are statically analyzable
 * by the bundler. Each action type maps to its step importer function.
 *
 * Generated entries: ${stepEntries.length}
 */

import "server-only";

// biome-ignore lint/suspicious/noExplicitAny: Dynamic step module types
type StepModule = Record<string, (input: any) => Promise<any>>;

export type StepImporter = {
  importer: () => Promise<StepModule>;
  stepFunction: string;
};

/**
 * Plugin step importers - maps action types to their step import functions
 * These imports are statically analyzable by the bundler
 */
export const PLUGIN_STEP_IMPORTERS: Record<string, StepImporter> = {
${importerEntries}
};

/**
 * Action labels - maps action IDs to human-readable labels
 * Used for displaying friendly names in the UI (e.g., Runs tab)
 */
export const ACTION_LABELS: Record<string, string> = {
${labelEntries}
${legacyLabelEntries}
};

/**
 * Get a step importer for an action type
 */
export function getStepImporter(actionType: string): StepImporter | undefined {
  return PLUGIN_STEP_IMPORTERS[actionType];
}

/**
 * Get the human-readable label for an action type
 */
export function getActionLabel(actionType: string): string | undefined {
  return ACTION_LABELS[actionType];
}
`;

  writeFileSync(STEP_REGISTRY_FILE, content, "utf-8");
  console.log(
    `üìù Generated lib/step-registry.ts with ${stepEntries.length} step(s)`
  );
}

/**
 * Main execution
 */
async function main(): Promise<void> {
  console.log("üîç Discovering plugins...");

  const plugins = discoverPlugins();
  const extensionPlugins = discoverExtensionPlugins();

  if (plugins.length === 0) {
    console.log("‚ö†Ô∏è  No plugins found in plugins/ directory");
  } else {
    console.log(`‚úÖ Found ${plugins.length} core plugin(s):`);
    for (const plugin of plugins) {
      console.log(`   - ${plugin}`);
    }
  }

  if (extensionPlugins.length === 0) {
    console.log("‚ÑπÔ∏è  No extension plugins found in extensions/plugins/");
  } else {
    console.log(`‚úÖ Found ${extensionPlugins.length} extension plugin(s):`);
    for (const plugin of extensionPlugins) {
      console.log(`   - ${plugin} (extension)`);
    }
  }

  console.log("\nüìù Generating plugins/index.ts...");
  generateIndexFile(plugins, extensionPlugins);

  console.log("üìö Updating README.md...");
  await updateReadme();

  console.log("üîß Generating lib/types/integration.ts...");
  await generateTypesFile();

  console.log("üîß Generating lib/step-registry.ts...");
  await generateStepRegistry(extensionPlugins);

  console.log("‚ú® Done! Plugin registry updated.\n");
}

main().catch((error) => {
  console.error("‚ùå Error:", error);
  process.exit(1);
});
